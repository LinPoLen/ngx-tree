<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>ngx-tree</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">ngx-tree</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>ScrollIntoViewTarget</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>projects/ngx-tree/src/models/tree-model.ts</code>
        </p>



        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#force">force</a>
                                </li>
                                <li>
                                        <a href="#node">node</a>
                                </li>
                                <li>
                                        <a href="#scrollToMiddle">scrollToMiddle</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="force"></a>
                                        <span class="name"><b>force</b><a href="#force"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>force:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="node"></a>
                                        <span class="name"><b>node</b><a href="#node"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>node:         <code><a href="../classes/TreeNode.html" target="_self" >TreeNode</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="../classes/TreeNode.html" target="_self" >TreeNode</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="scrollToMiddle"></a>
                                        <span class="name"><b>scrollToMiddle</b><a href="#scrollToMiddle"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>scrollToMiddle:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/boolean" target="_blank" >boolean</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import compact from &#x27;lodash-es/compact&#x27;
import find from &#x27;lodash-es/find&#x27;
import first from &#x27;lodash-es/first&#x27;
import isFunction from &#x27;lodash-es/isFunction&#x27;
import isString from &#x27;lodash-es/isString&#x27;
import last from &#x27;lodash-es/last&#x27;
import { Observer, Subject } from &#x27;rxjs&#x27;
import { EventsMap, TREE_EVENTS } from &#x27;../constants/events&#x27;
import { TreeEvent } from &#x27;./events&#x27;
import { TreeNode } from &#x27;./tree-node&#x27;
import { createTreeDataOptions, TreeDataOptions } from &#x27;./tree-options&#x27;

export interface ScrollIntoViewTarget {
    node: TreeNode
    force: boolean
    scrollToMiddle: boolean
}

export class TreeModel {
    /**
     * static cache for recording the tree model while using multiple tree component in same container.
     */
    static focusedTree: TreeModel | null &#x3D; null

    /**
     * a tree node created internally to represent the root node of input data
     */
    readonly virtualRoot: TreeNode
    readonly scrollIntoView$: Subject&lt;ScrollIntoViewTarget&gt; &#x3D; new Subject()

    /**
     * Is the tree currently focused
     */
    get isFocused() {
        return TreeModel.focusedTree &#x3D;&#x3D;&#x3D; this
    }

    /**
     * if the tree is empty
     */
    get isEmptyTree() {
        return this.roots &amp;&amp; this.roots.length &#x3D;&#x3D;&#x3D; 0
    }

    /**
     * Current focused node
     */
    get focusedNode() {
        return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null
    }

    /**
     * @returns Current expanded nodes
     */
    get expandedNodes(): TreeNode[] {
        const nodes &#x3D; Array.from(this.expandedNodeIds.keys())
            .filter((id) &#x3D;&gt; this.expandedNodeIds.get(id))
            .map((id) &#x3D;&gt; this.getNodeById(id))

        return compact(nodes)
    }

    /**
     * @returns Current active (selected) nodes
     */
    get activeNodes(): TreeNode[] {
        const nodes &#x3D; Array.from(this.activeNodeIds.keys())
            .filter((id) &#x3D;&gt; this.activeNodeIds.get(id))
            .map((id) &#x3D;&gt; this.nodeCache.get(id))

        return compact(nodes)
    }

    /**
     * All root nodes, it will have one item if a user input a single root tree.
     */
    get roots(): TreeNode[] {
        return this.virtualRoot.children
    }

    options: TreeDataOptions

    private focusedNodeId: string | null &#x3D; null
    private expandedNodeIds: Map&lt;string, boolean&gt; &#x3D; new Map()
    private activeNodeIds: Map&lt;string, boolean&gt; &#x3D; new Map()
    private hiddenNodeIds: Map&lt;string, boolean&gt; &#x3D; new Map()
    private nodeCache: Map&lt;string, TreeNode&gt; &#x3D; new Map()

    constructor(
        private nodes: any[],
        public events: EventsMap,
        /**
         * Options that are passed to the tree component
         */
        options?: TreeDataOptions,
    ) {
        this.options &#x3D; createTreeDataOptions(options)
        const virtualRootConfig &#x3D; {
            virtual: true,
            // todo: determine to use fixed children field later
            [this.options.childrenField!]: this.nodes,
        }

        this.virtualRoot &#x3D; new TreeNode(virtualRootConfig, null, this, 0)
        this.setExpandedNodeInPlace(this.virtualRoot)
    }

    addCache(node: TreeNode) {
        this.nodeCache.set(node.id, node)
    }

    updateOptions(options: TreeDataOptions) {
        this.options &#x3D; options
    }

    // events
    fireEvent(event: TreeEvent) {
        // event.treeModel &#x3D; this

        this.events[&lt;keyof EventsMap&gt;event.eventName].emit(event)
    }

    subscribe(eventName: string, fn: Observer&lt;TreeEvent&gt;) {
        return this.events[&lt;keyof EventsMap&gt;eventName].subscribe(fn)
    }

    // getters
    /**
     * @returns Current active (selected) node. If multiple nodes are active - returns the first one.
     */
    getActiveNode(): TreeNode {
        return this.activeNodes[0]
    }

    /**
     * @returns All root nodes that pass the current filter
     */
    getVisibleRoots() {
        return this.virtualRoot.visibleChildren
    }

    /**
     * @param skipHidden  true or false - whether to skip hidden nodes
     * @returns      first root of the tree
     */
    getFirstRoot(skipHidden &#x3D; false) {
        return first(skipHidden ? this.getVisibleRoots() : this.roots)
    }

    /**
     * @param skipHidden  true or false - whether to skip hidden nodes
     * @returns      last root of the tree
     */
    getLastRoot(skipHidden &#x3D; false) {
        return last(skipHidden ? this.getVisibleRoots() : this.roots)
    }

    // locating nodes
    /**
     * @param     path  array of node IDs to be traversed respectively
     * @param     startNode  optional. Which node to start traversing from
     * @returns   The node, if found - null otherwise
     */
    getNodeByPath(path: (string | number)[], startNode: TreeNode | null &#x3D; null): TreeNode | null {
        if (!path) {
            return null
        }

        startNode &#x3D; startNode || this.virtualRoot

        if (path.length &#x3D;&#x3D;&#x3D; 0) {
            return startNode
        }

        if (!startNode.children) {
            return null
        }

        const childId &#x3D; path.shift()
        const childNode &#x3D; find&lt;TreeNode&gt;(startNode.children, { id: childId } as any)

        if (!childNode) {
            return null
        }

        return this.getNodeByPath(path, childNode)
    }

    /**
     * @param     id  node ID to find
     * @returns   The node, if found - null otherwise
     */
    getNodeById(id: string) {
        return this.nodeCache.get(id)
    }

    /**
     * @param     predicate - either an object or a function, used as a test condition on all nodes.
     *            Could be every predicate that&#x27;s supported by lodash&#x27;s &#x60;find&#x60; method
     * @param     startNode  optional. Which node to start traversing from
     * @returns   First node that matches the predicate, if found - null otherwise
     */
    getNodeBy(predicate: (node: TreeNode) &#x3D;&gt; boolean, startNode: TreeNode | null &#x3D; null): TreeNode | null {
        // todo: refactor to a loop
        startNode &#x3D; startNode || this.virtualRoot

        if (!startNode.children) {
            return null
        }

        const found &#x3D; find(startNode.children, predicate)

        if (found) { // found in children
            return found
        } else { // look in children&#x27;s children
            for (const child of startNode.children) {
                const foundInChildren &#x3D; this.getNodeBy(predicate, child)
                if (foundInChildren) {
                    return foundInChildren
                }
            }
        }

        return null
    }

    isNodeExpanded(node: TreeNode) {
        return !!this.expandedNodeIds.get(node.id)
    }

    isNodeHidden(node: TreeNode) {
        return !!this.hiddenNodeIds.get(node.id)
    }

    isNodeActive(node: TreeNode) {
        return !!this.activeNodeIds.get(node.id)
    }

    isNodeFocused(node: TreeNode) {
        return this.focusedNode &#x3D;&#x3D;&#x3D; node
    }

    setActiveNode(node: TreeNode, isActive: boolean, isMulti &#x3D; false) {
        if (isMulti) {
            this.setMultiActiveNodes(node, isActive)
        } else {
            this.setSingleActiveNode(node, isActive)
        }

        if (isActive) {
            node.focus()
            this.fireEvent({ eventName: TREE_EVENTS.activate, node })
        } else {
            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node })
        }
    }

    setExpandedNodeInPlace(node: TreeNode, isExpanded &#x3D; true) {
        this.expandedNodeIds.set(node.id, isExpanded)
    }

    setExpandedNode(node: TreeNode, isExpanded &#x3D; true) {
        this.expandedNodeIds.set(node.id, isExpanded)
        if (isExpanded) {
            this.fireEvent({ eventName: TREE_EVENTS.expand, node })
        } else {
            this.fireEvent({ eventName: TREE_EVENTS.collapse, node })
        }
        this.fireEvent({ eventName: TREE_EVENTS.toggleExpander, node, isExpanded })
    }

    setHiddenNode(node: TreeNode, isHidden &#x3D; true) {
        this.hiddenNodeIds.set(node.id, isHidden)
    }

    /**
     * Set focus on a node
     * @param node
     */
    setFocusedNode(node: TreeNode | null) {
        this.focusedNodeId &#x3D; node ? node.id : null
    }

    /**
     * Focuses or blurs the tree
     * @param value  true or false - whether to set focus or blur.
     */
    setFocus(value: boolean) {
        TreeModel.focusedTree &#x3D; value ? this : null
    }

    traverse(fn: (node: TreeNode) &#x3D;&gt; any) {
        this.roots.forEach((root) &#x3D;&gt; root.traverse(fn))
    }

    activateNode(id: string) {
        const target &#x3D; this.getNodeById(id)
        if (target) {
            target.setActiveAndVisible()

            return true
        }

        return false
    }

    focusNode(id: string) {
        const target &#x3D; this.getNodeById(id)
        if (target) {
            target.focus()

            return true
        }

        return false
    }

    /**
     * Focuses on the next node in the tree (same as down arrow)
     */
    focusNextNode() {
        const previousNode &#x3D; this.focusedNode
        const nextNode &#x3D; previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true)
        if (nextNode) {
            nextNode.focus()
        }
    }

    /**
     * Focuses on the previous node in the tree (same as up arrow)
     */
    focusPreviousNode() {
        const previousNode &#x3D; this.focusedNode
        const nextNode &#x3D; previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true)
        if (nextNode) {
            nextNode.focus()
        }
    }

    /**
     * Focuses on the inner child of the current focused node (same as right arrow on an expanded node)
     */
    focusDrillDown() {
        const previousNode &#x3D; this.focusedNode
        if (previousNode &amp;&amp; previousNode.isCollapsed &amp;&amp; previousNode.hasChildren) {
            previousNode.toggleExpanded()
        } else {
            const nextNode &#x3D; previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true)
            if (nextNode) {
                nextNode.focus()
            }
        }
    }

    /**
     * Focuses on the parent of the current focused node (same as left arrow on a collapsed node)
     */
    focusDrillUp() {
        const previousNode &#x3D; this.focusedNode
        if (!previousNode) {
            return
        }

        if (previousNode.isExpanded) {
            previousNode.collapse()
        } else {
            const nextNode &#x3D; previousNode.parent
            if (nextNode) {
                nextNode.focus()
            }
        }
    }

    /**
     * expand all nodes
     */
    expandAll() {
        this.roots.forEach((root) &#x3D;&gt; root.expandAll())
    }

    /**
     * collapse all nodes
     */
    collapseAll() {
        this.roots.forEach((root) &#x3D;&gt; root.collapseAll())
    }

    performKeyAction(node: TreeNode, $event: KeyboardEvent) {
        // todo: the keyCode is deprecated on MDN, replace it some day
        const action &#x3D; this.options.actionMapping!.keys![$event.keyCode]
        if (action) {
            $event.preventDefault()
            action(this, node, $event)

            return true
        } else {
            return false
        }
    }

    /**
     * Marks isHidden field in all nodes recursively according to the filter param.
     * If a node is marked visible, all of its ancestors will be marked visible as well.
     * @param filter  either a string or a function.
     *   In case it&#x27;s a string, it will be searched case insensitively in the node&#x27;s display attribute
     *   In case it&#x27;s a function, it will be passed the node, and should return true if the node should be visible,
     *     false otherwise
     * @param autoShow  if true, make sure all nodes that passed the filter are visible
     */
    filterNodes(filter: string | ((node: TreeNode) &#x3D;&gt; boolean), autoShow &#x3D; true) {
        let filterFn: any

        if (!filter) {
            return this.clearFilter()
        }

        // support function and string filter
        if (isString(filter)) {
            filterFn &#x3D; (node: TreeNode) &#x3D;&gt; node.displayField.toLowerCase().includes(filter.toLowerCase())
        } else if (isFunction(filter)) {
            filterFn &#x3D; filter
        } else {
            throw new TypeError(&#x60;Don&#x27;t know what to do with filter: ${filter}. It should be either a string or function&#x60;)
        }

        const ids &#x3D; new Map()
        this.roots.forEach((node) &#x3D;&gt; this.filterNode(ids, node, filterFn, autoShow))
        this.hiddenNodeIds &#x3D; ids
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter })
    }

    /**
     * Marks all nodes isHidden &#x3D; false
     */
    clearFilter() {
        this.hiddenNodeIds &#x3D; new Map()
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter })
    }

    /**
     * moves a node from one location in the tree to another
     * @param node location has a from and a to attributes, each has a node and index attributes.
     * The combination of node + index tells which node needs to be moved, and to where
     * @param to
     */
    moveNode(node: TreeNode, to: { parent: TreeNode, index: number, dropOnNode: boolean }) {
        const fromIndex &#x3D; node.index
        const fromParent &#x3D; node.parent

        if (!canMoveNode(node, fromIndex, to)) {
            return
        }

        node.remove()

        // Compensate for index if already removed from parent:
        const toIndex &#x3D; (fromParent &#x3D;&#x3D;&#x3D; to.parent &amp;&amp; to.index &gt; fromIndex) ? to.index - 1 : to.index

        if (to.dropOnNode) {
            to.parent.appendChild(node.data)
        } else {
            to.parent.addChild(node.data, toIndex)
        }

        this.fireEvent({
            eventName: TREE_EVENTS.moveNode,
            node,
            to: { parent: to.parent.data, index: toIndex },
        })
    }

    scrollIntoView(node: TreeNode, force: boolean, scrollToMiddle &#x3D; true) {
        this.scrollIntoView$.next({
            node, force, scrollToMiddle,
        })
    }

    private filterNode(
        ids: Map&lt;string, boolean&gt;,
        node: TreeNode,
        filterFn: (node: TreeNode) &#x3D;&gt; boolean,
        autoExpand: boolean,
    ) {
        // if node passes function then it&#x27;s visible
        let isVisible &#x3D; filterFn(node)

        if (node.children) {
            // if one of node&#x27;s children passes filter then this node is also visible
            node.children.forEach((child) &#x3D;&gt; {
                if (this.filterNode(ids, child, filterFn, autoExpand)) {
                    isVisible &#x3D; true
                }
            })
        }

        // mark node as hidden
        if (!isVisible) {
            ids.set(node.id, true)
        }

        // auto expand parents to make sure the filtered nodes are visible
        if (autoExpand &amp;&amp; isVisible) {
            node.ensureVisible()
        }

        return isVisible
    }

    private setSingleActiveNode(node: TreeNode, active: boolean) {
        // Deactivate all other nodes:
        this.activeNodes
            .filter((activeNode) &#x3D;&gt; activeNode !&#x3D;&#x3D; node)
            .forEach((activeNode) &#x3D;&gt; {
                this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode })
            })

        if (active) {
            this.activeNodeIds &#x3D; new Map([[node.id, true]])
        } else {
            this.activeNodeIds &#x3D; new Map()
        }
    }

    private setMultiActiveNodes(node: TreeNode, active: boolean) {
        this.activeNodeIds.set(node.id, active)
    }
}

function canMoveNode(node: TreeNode, fromIndex: number, to: { parent: TreeNode, index: number }) {
    // same node:
    if (node.parent &#x3D;&#x3D;&#x3D; to.parent &amp;&amp; fromIndex &#x3D;&#x3D;&#x3D; to.index) {
        return false
    }

    return !to.parent.isDescendantOf(node)
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ScrollIntoViewTarget.html';
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
